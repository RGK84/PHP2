Задание 1.5. Дан код:
Что он выведет на каждом шаге? Почему?

class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
$a1 = new A(); // ничего не выводит, создается новый экземпляр класса
$a2 = new A(); // ничего не выводит, создается новый экземпляр класса
$a1->foo(); // выводит 1, т.к. преинкремент сначала увеличивает $x на 1, а потом отдает значение в функцию echo
$a2->foo(); // выводит 2, т.к. использование ключевого слова static позволяет использовать переменную при следующем вызове функции, т.е. она не стирается из памяти, а сохраняется с последним заданным значением.
$a1->foo(); // выводит 3, т.к. static и преинкремент
$a2->foo(); // выводит 4, т.к. static и преинкремент

Задание 1.6. Немного изменим п.5:
Объясните результаты в этом случае.

class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A(); // ничего не выводит, создается новый экземпляр класса A
$b1 = new B(); // ничего не выводит, создается новый экземпляр класса B
$a1->foo();  // выводит 1, т.к. преинкремент сначала увеличивает $x на 1, а потом отдает значение в функцию echo
$b1->foo(); // выводит 1, т.к. метод foo ссылается на другой класс, и опять-таки преинкремент сначала увеличивает $x на 1, а потом отдает значение в функцию echo
$a1->foo(); // выводит 2, т.к. использование ключевого слова static позволяет использовать переменную при следующем вызове функции, т.е. она не стирается из памяти, а сохраняется с последним заданным значением.
$b1->foo(); // выводит 2, т.к. static и экземпляр другого класса, где последнее значение переменной $x было 1.

Задание 1.7.* Дан код:
Что он выведет на каждом шаге? Почему?
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B extends A {
}
$a1 = new A; // ничего не выводит, создается нового объекта A
$b1 = new B; // ничего не выводит, создается нового объекта B
$a1->foo(); // выводит 1, т.к. преинкремент сначала увеличивает $x на 1, а потом отдает значение в функцию echo
$b1->foo(); // выводит 1. Т.к. A и B – классы, то для них существует динамический метод foo. И хотя он один, в него пробрасывается свой $this при каждом обращении к объектам. Т.е. в контексте $b->foo, будет пробрасываться $this = текущий_объект ($b).
$a1->foo(); // выводит 2, т.к. static и последнее значение переменной $x для объекта $a было 1.
$b1->foo(); // выводит 2, т.к. static и последнее значение переменной $x для объекта $b было 1.

